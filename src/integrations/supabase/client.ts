// This file is automatically generated. Do not edit it directly.
import { createClient, type SupabaseClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

let supabase: SupabaseClient<Database> | null = null;

if (typeof SUPABASE_URL === 'string' && SUPABASE_URL && typeof SUPABASE_PUBLISHABLE_KEY === 'string' && SUPABASE_PUBLISHABLE_KEY) {
  supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
    auth: {
      storage: localStorage,
      persistSession: true,
      autoRefreshToken: true,
    }
  });
} else {
  // Fallback shim: implement a minimal, chainable stub to avoid runtime errors
  // when the project isn't configured with Supabase. It logs warnings and
  // returns safe defaults. This keeps UI functional while you wire the
  // backend or set real Supabase env vars.
  // eslint-disable-next-line no-console
  console.warn('[supabase] VITE_SUPABASE_URL or VITE_SUPABASE_PUBLISHABLE_KEY is not set. Using fallback shim.');

  const stubAuth = {
    async getSession() { return { data: { session: null } }; },
    async getUser() { return { data: { user: null } }; },
    onAuthStateChange(cb: any) { return { data: { subscription: { unsubscribe() {} } } }; },
    async signInWithPassword() { return { data: {}, error: { message: 'Supabase not configured' } }; },
    async signUp() { return { data: {}, error: { message: 'Supabase not configured' } }; },
  } as any;

  const makeChain = () => {
    const chain: any = {
      select() { return chain; },
      eq() { return chain; },
      match() { return chain; },
      gte() { return chain; },
      lte() { return chain; },
      gt() { return chain; },
      lt() { return chain; },
      neq() { return chain; },
      is() { return chain; },
      contains() { return chain; },
      order: () => chain,
      limit: () => chain,
      range: () => chain,
      // finalizers
      maybeSingle: async () => ({ data: null, error: { message: 'Supabase not configured' }, count: 0 }),
      single: async () => ({ data: null, error: { message: 'Supabase not configured' }, count: 0 }),
      insert: async () => ({ data: null, error: { message: 'Supabase not configured' }, count: 0 }),
      update: async () => ({ data: null, error: { message: 'Supabase not configured' }, count: 0 }),
      delete: async () => ({ data: null, error: { message: 'Supabase not configured' }, count: 0 }),
    };

    // Make the chain awaitable so Promise.all(...) works when the real supabase client
    // isn't configured. It resolves to a standard response shape.
    chain.then = (onFulfilled: any, onRejected: any) => {
      const result = { data: null, error: { message: 'Supabase not configured' }, count: 0 };
      try {
        return Promise.resolve(result).then(onFulfilled, onRejected);
      } catch (e) {
        return Promise.reject(e).catch(onRejected);
      }
    };

    return chain;
  };

  const stubFrom = (_table: string) => makeChain();

  // Export a lightweight object compatible with common supabase usage in the app
  // Note: this is a client-side-only shim and does not talk to the DB.
  // Replace with a proper backend integration for full functionality.
  // @ts-ignore
  supabase = {
    auth: stubAuth,
    from: stubFrom,
  } as unknown as SupabaseClient<Database>;
}

export { supabase };